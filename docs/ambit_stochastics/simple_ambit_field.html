<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ambit_stochastics.simple_ambit_field API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ambit_stochastics.simple_ambit_field</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">###################################################################
#imports 
from collections     import Counter
from itertools       import chain
from scipy.optimize  import fsolve
from scipy.integrate import quad
import numpy as np
import math
import time
from numba import njit

from .helpers.input_checks import check_trawl_function
from .helpers.input_checks  import check_jump_part_and_params
from .helpers.input_checks  import check_gaussian_params
from .helpers.input_checks import check_spatio_temporal_positions

from .helpers.sampler import gaussian_part_sampler
from .helpers.sampler import jump_part_sampler
###################################################################

class simple_ambit_field:
    def __init__(self, x, tau, k_s, k_t, nr_simulations, ambit_function=None, decorrelation_time=-np.inf,
                 gaussian_part_params=None, jump_part_name=None, jump_part_params=None,
                 batch_size=None, total_nr_samples=None, values=None):
        &#34;&#34;&#34;Container class for the simulation, parameter inference and forecasting of ambit fields of the
        form \(Y_t(x) = L(A+(x,t))\).
        
        Args:
          x: positive number: spacing between ambit sets on the space axis.
          tau: positive number: spacing between ambit sets on the time axis.
          k_s: positive integer: number of ambit sets on the space axix.
          k_t: positive integer: number of ambit sets on the time axis.
          nr_simulation: positive integer: number of simulations.
          ambit_function: a non-negative, continuous, strictly increasing function
          \(\phi \colon (-\infty,0] \\to [0,\infty)\) with \(\phi(1) &gt; 0, \phi(t) =0\) for \(t&gt;0\).
          decorrelation_time: \(-\infty\) if the ambit set A is unbounded and finite, negative otherwise.
          gaussian_part_params: tuple with the mean and standard deviation of the Gaussian part.                                                           
          jump_part_name: tuple with the parameters of the jump part distribution check helpers.sampler 
          for the parametrisation.
          jump_part_params: string: name of the jump part distribution. check helpers.sampler for the parametrisation.
          batch_size: positive integer: number of points to be used at once in the `approximate_slices` method,
          in order to optimise for cache memory.
          total_nr_samples: positive integer: total number of points to be used in the `approximate_slices` method.
          values: a numpy array with shape \([\\text{nr_simulations},k_s,k_t]\) which is passed by the user or 
          simulated with the method `simple_ambit_field.simulate`.
        &#34;&#34;&#34;

        #################################################################################
        check_spatio_temporal_positions(x, tau, k_s, k_t, nr_simulations)
        self.x = x
        self.tau = tau
        self.k_s = k_s
        self.k_t = k_t
        self.nr_simulations = nr_simulations

        ### simulation parameters ###
        self.ambit_function = ambit_function
        self.gaussian_part_params = gaussian_part_params
        self.jump_part_name = jump_part_name
        self.jump_part_params = jump_part_params
        self.decorrelation_time = decorrelation_time
        self.total_nr_samples = total_nr_samples
        self.batch_size = batch_size

        ### dimension of the indicator matrix for each minimal slice 
        ### if decorrelation_time &gt;  -inf, I_t = ceiling(decorrelation_time/tau)
        ### if decorrelation_time =  -inf, I_t = k_t - T/tau,
        ### where T = tau * floor{\phi^{-1}(x)/tau + 1} ###
        self.I_t = None
        self.I_s = None   #I_s = math.ceil(self.ambit_function(0)/self.x)


        ### minimal slices on t &gt; T/tau ###
        self.unique_slices = None
        self.unique_slices_areas = None
        
        ### correction slices given by the intersections of ambit sets \(A_ij\) with \(1 \le i \le k_s, 1 \le j \le k_t\)
        ### with \(t &lt; T/tau\), which we list from left to right in an array
        self.correction_slices_areas = None
        
        ### container for gaussian and jump parts. their sum is the result ###
        self.gaussian_values = None
        self.jump_values = None
        
        ### passed by the user or simulated using the simulate method 
        ### must have shape [nr_simulations,k_s,k_t] ###
        if values == None:
            self.values = None

        else:

            assert isinstance(
                values, np.ndarray), &#39;the values argument is not a numpy array&#39;
            assert values.shape == (
                nr_simulations, k_s, k_t), &#39;please check the shape of the values argument&#39;
            self.values = values

        #########################################################################################
        ### infered simulation parameters: skip this if you are only interested in simulations###
        self.inferred_parameters = None

        # self.inferred_parameters is a list with elements dictionaries of the form
        # {&#39;inferred_ambit_function_name&#39;:   , inferred_ambit_function_params:    ,
        # &#39;inferred_gaussian_params&#39;:        ,&#39;inferred_jump_params&#39;:              }

        # inferred_ambit_function        is &#39;exponential&#39;,&#39;gamma&#39;, &#39;ig&#39; or a lambda function
        # inferred_ambit_function_params is a tuple
        # inferred_gaussian_params       is a tuple containing the mean and scale
        # inferred_jump_params           is a dictionary containing the name of the distribution
        # and its params, such as {&#39;gamma&#39;: (1,1)}
        ##########################################################################################

    def delete_values(self):
        &#34;&#34;&#34;Deletes the `values` attribute&#34;&#34;&#34;
        if self.values != None:
            self.values = None
            print(&#39;self.values has been deleted&#39;)
        #else:
            #print(&#39;no values to delete&#39;)

    def determine_slices_from_points(self, points_x, points_t):
        &#34;&#34;&#34;Helper for the &#39;approximate_slices&#39; method. Given random points with coordinates 
        `points_x` and `points_t` coordinates from the uniform distribution on \([x,x+\phi(0)] \\times [0,\\tau]\)
        which do not belong to \(A_{01}\) or \(A_{10}\), we check in which slice \(S\) of \(\mathcal{S}_{kl}\) each point is.
        we do so by using a 3d array with shape  \([\\text{nr_sampled_points},I_s,I_t]\) where the \(i^{\\text{th}}\) element \([i,:,:]\) is a matrix with \(\\text{kl}^{\\text{th}}\) element
        is a boolean given by \(x_i - x \cdot k &lt; \phi(t_i -t \cdot l) \cdot (T &lt; t_i-t \cdot l &lt;0)\)
        where \((x_i,t_i)\)  are the coordinates of the \(i^{\\text{th}}\) uniform random sample. 
        [check description of the indicator here]
        
        Args:\n 
          points_x: x coordinates of the uniformly sampled points
          points_t: t coordinates of the uniformly sampled points
        
        Returns:
          a dictionary with keys given by tuples which represent the indicator matrices of 
          a minimal slice and values given by the number of points contained in the minimal slice
        &#34;&#34;&#34;

        # coordinates at which the ambit field is simulated
        ambit_t_coords = self.tau * np.arange(1, self.I_t+1)
        ambit_x_coords = self.x * np.arange(1, self.I_s+1)
        
        x_ik = np.subtract.outer(points_x, ambit_x_coords)
        x_ikl = np.repeat(x_ik[:, :, np.newaxis], repeats=self.I_t, axis=2)
        t_il = np.subtract.outer(points_t, ambit_t_coords)
        phi_t_ikl = np.repeat(self.ambit_function(
            t_il)[:, np.newaxis, :], repeats=self.I_s, axis=1)
        range_indicator = x_ik &gt; 0
        range_indicator = np.repeat(
            range_indicator[:, :, np.newaxis], repeats=self.I_t, axis=2)

        indicator = (x_ikl &lt; phi_t_ikl) * range_indicator
        
        #in the unlikely case no minimal slice is identified
        if len(indicator) == 0:
            raise ValueError(&#39;use more samples in each batch&#39;)

        # we enumerate the unique indicator matrices together with the frequency counts
        # we change the shape from [total_nr_samples, I_s, I_t]  to [total_nr_samples, I_s * I_t]
        reshaped_indicator = indicator.reshape(indicator.shape[:-2]+(-1,))
        g = (tuple(i) for i in reshaped_indicator)
        return Counter(chain(g))

    def approximate_slices(self):
        &#34;&#34;&#34;Identifies the minimal slices in \(S_{11}\) together with their areas and assigns these value to attributes
        `unique_slices` and `unique_slices_areas`.&#34;&#34;&#34;
        
        print(&#39;Slice estimation procedure has started&#39;)
        start_time = time.time()

        
        if self.batch_size == None:
            self.batch_size = self.total_nr_samples // 10
        self.total_nr_samples = self.batch_size * (self.total_nr_samples // self.batch_size)

        # rectangle to simulate uniform rvs in space-time is [x, x + ambit_function(0)] x [0,tau]
        low_x, high_x = self.x, self.x + self.ambit_function(0)
        low_t, high_t = max(self.tau + self.decorrelation_time, 0), self.tau
        dict_ = dict()

        #use batches of points to optimise for cache memory and prevent memory overflow 
        for batch in range(self.total_nr_samples // self.batch_size):

            points_x = np.random.uniform(
                low=low_x, high=high_x, size=self.batch_size)
            points_t = np.random.uniform(
                low=low_t, high=high_t, size=self.batch_size)

            # throw away points not contained in A_11 = A + (x,tau):
            # (points_x,points_t) in A_11 if: 0 &lt; points_x - x &lt; phi(points_t - tau)
            # i.e. throw away points contained in ambit sets bottom or left of A_11
            # left of A_11: no such points, since we only simulate points with t coordinate &gt; 0
            # bottom of A_11: must be in A_01; condition: (points_x &lt; phi(points_t - tau)) *  (points_x  &gt; 0)

            indicator_in_A_11 = (
                points_x - self.x &lt; self.ambit_function(points_t - self.tau)) * (points_x - self.x &gt; 0)
            indicator_in_A_01 = (points_x &lt; self.ambit_function(
                points_t - self.tau)) * (points_x &gt; 0)
            indicator_bottom_of_A_11 = indicator_in_A_11 * (~indicator_in_A_01)

            points_x = points_x[indicator_bottom_of_A_11]
            points_t = points_t[indicator_bottom_of_A_11]

            dict_to_add = self.determine_slices_from_points(points_x, points_t)

            for k, v in dict_to_add.items():
                if k in dict_:
                    dict_[k] += v
                else:
                    dict_[k] = v
                    
        # to add more diagnostics
        print(&#39;Slice estimation procedure has finished&#39;)
        end_time = time.time()
        print(end_time - start_time)
        
        percentage_points_kept = 100 * sum(dict_.values()) / self.total_nr_samples
        print(f&#34;{round(percentage_points_kept,2)}% of points are used in the slice estimation&#34;)

        nr_unique_indicators = len(dict_.keys())
        self.unique_slices = np.array(list(dict_.keys())).reshape(
            nr_unique_indicators, self.I_s, self.I_t)
        
        self.unique_slices_areas = np.array(list(dict_.values())) * (high_x-low_x) * \
            (high_t - low_t) / self.total_nr_samples
            
            
    def determine_correction_slices(self,T):
        &#34;&#34;&#34;Method to be used in the infinite decorrelation time to determine the areas of the
        intersection of the ambit sets at time coordinates \(\\tau,\ldots, k_t \\tau\) with 
        the region of the plane given by \(t &lt; T\). The result is stored in the attribute
        `correction_slices_areas`.
        &#34;&#34;&#34;
        
        self.correction_slices_areas = [quad(self.ambit_function, a = T - (i+1) * self.tau, b= T - i * self.tau , limit=500)[0]  
                                        for i in range(1,self.k_t)] + [quad(self.ambit_function,a= -np.inf,b=T - self.k_t,limit=500)[0]]
 
        
    @njit
    def simulate_finite_decorrelation_time(self):
        &#34;&#34;&#34;implementation of algorithm  [nr to be added] in [paper link]&#34;&#34;&#34;
        Y_gaussian = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,self.k_t + 2 * self.I_t-2))
        Y_jump     = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,self.k_t + 2 * self.I_t-2))
        for k in range(self.k_s + self.I_s -1):
            for l in range(self.k_t + self.I_t - 1):
                
                gaussian_to_add = np.zeros((self.k_s,self.k_t))
                jump_to_add     = np.zeros((self.k_s,self.k_t))
                
                #simulate S.
                for slice_S,area_S in zip(self.unique_slices,self.unique_slices_areas):
                    tiled_area_S = np.tile(area_S,(self.nr_simulations,1))
                    
                    gaussian_sample_slice = gaussian_part_sampler(self.gaussian_part_params,tiled_area_S)
                    jump_sample_slice     = jump_part_sampler(self.jump_part_params,tiled_area_S,self.jump_part_name)
                    
                    gaussian_to_add += slice_S * gaussian_sample_slice[:,:,np.newaxis]
                    jump_to_add     += slice_S * jump_sample_slice[:,:,np.newaxis]
                    
                Y_gaussian[:,k:k+self.I_s,l:l+self.I_t] +=  gaussian_to_add
                Y_jump[:,k:k+self.I_s,l:l+self.I_t]     +=  jump_to_add
 
        self.gaussian_values =  Y_gaussian[:,self.I_s-1:self.I_s+self.k_s-1,self.I_t-1:self.I_t+self.k_t-1]
        self.jump_values     =  Y_jump[:,self.I_s-1:self.I_s+self.k_s-1,self.I_t-1:self.I_t+self.k_t-1]

    @njit
    def simulate_infinite_decorrelation_time(self,T):
        &#34;&#34;&#34;implementation of algorithm  [nr to be added] in [paper link]&#34;&#34;&#34;

        assert T/self.tau == int(T/self.tau)
        T_tau = -int(T/self.tau)
        
        Y_gaussian = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,2 * self.k_t + 2 * T_tau -1))
        Y_jump     = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,2 * self.k_t + 2 * T_tau -1))
        
        #add correction slices
        self.determine_correction_slices(T)
        correction_slices_matrix   = np.tile(self.correction_slices_areas,(self.nr_simulations,self.k_s,1))
        gaussian_correction_slices = gaussian_part_sampler(self.gaussian_part_params,correction_slices_matrix)
        jump_correction_slices     = jump_part_sampler(self.jump_part_params,correction_slices_matrix,self.jump_part_name)
        
        #gaussian_correction_slices = np.fliplr(np.cumsum(np.fliplr(gaussian_correction_slices),axis=1))
        #jump_correction_slices     = np.fliplr(np.cumsum(np.fliplr(jump_correction_slices),axis=1))
        gaussian_correction_slices = (np.cumsum(gaussian_correction_slices[:,:,::-1],axis=2))[:,:,::-1]
        jump_correction_slices     = (np.cumsum(jump_correction_slices[:,:,::-1],axis=2))[:,:,::-1]

        
        Y_gaussian[:,self.I_s-1:self.I_s - 1+ self.k_s, T_tau:T_tau + self.k_t] +=  gaussian_correction_slices  
        Y_jump[:,self.I_s-1:self.I_s - 1+ self.k_s, T_tau:T_tau + self.k_t]     +=  jump_correction_slices  

        #implementation of algorithm [] from []
        for k in range(self.k_s + self.I_s -1):
            for l in range(self.k_t +  T_tau):

                gaussian_to_add = np.zeros((self.nr_simulations,self.I_s,self.I_t))
                jump_to_add     = np.zeros((self.nr_simulations,self.I_s,self.I_t))
                
                for slice_S,area_S in zip(self.unique_slices,self.unique_slices_areas):
                    tiled_area_S = np.tile(area_S,(self.nr_simulations,1))
                    #simulate S
                    
                    gaussian_sample_slice = gaussian_part_sampler(self.gaussian_part_params,tiled_area_S)
                    jump_sample_slice     = jump_part_sampler(self.jump_part_params,tiled_area_S,self.jump_part_name)
                    
                    gaussian_to_add = slice_S * gaussian_sample_slice[:,:,np.newaxis] 
                    jump_to_add     = slice_S * jump_sample_slice[:,:,np.newaxis] 
                    
                Y_gaussian[:,k:k+self.I_s,l:l+self.I_t] +=  gaussian_to_add
                Y_jump[:,k:k+self.I_s,l:l+self.I_t]     +=  jump_to_add
                    
                    
        self.gaussian_values = Y_gaussian[:,self.I_s-1:self.I_s - 1+ self.k_s,T_tau+1: T_tau+self.k_t+1]
        self.jump_values     = Y_jump[:,self.I_s-1:self.I_s-1+self.k_s,T_tau+1:T_tau+1+self.k_t]
                
    def simulate(self):
        &#34;&#34;&#34;Simulate the ambit field at time coordinates \(\\tau,\ldots,k_t\\tau\) and space
        coordinates \(x,\ldots,k_s x\). The marginal law of this stationary
        process is given by the independent sum of the Gaussian and jump parts. See [] for an example
        and `helpers.sampler&#39; for the parametrisations used. The simulated values are stored in the
        attribute `values`.&#34;&#34;&#34;

        # checks
        self.delete_values()
        check_trawl_function(self.ambit_function)
        check_gaussian_params(self.gaussian_part_params)
        check_jump_part_and_params(self.jump_part_name,self.jump_part_params)



        #set I_s
        self.I_s = math.ceil(self.ambit_function(0)/self.x)
        # set I_t
        if self.decorrelation_time &gt; -np.inf:    
            
            # decorrelation_time checks
            assert self.decorrelation_time &lt; 0, &#39;please check the value of the decorrelation_time&#39;
            assert self.ambit_function(self.decorrelation_time) == 0,\
                            &#39;ambit_function(decorrelation_time) should be 0&#39;
            self.I_t = math.ceil(-self.decorrelation_time/self.tau)
            
            

        elif self.decorrelation_time == -np.inf:
            
            T_tilde = fsolve(lambda t: self.ambit_function(t)-self.x,x0=-1)[0]
            T = self.tau * math.floor(1 + T_tilde/self.tau)
            assert (T/self.tau).is_integer()
            
            self.I_t = int(-T / self.tau) + self.k_t
            
        self.approximate_slices()
        
        if  self.decorrelation_time &gt; -np.inf:           
            self.simulate_finite_decorrelation_time()
            
        elif self.decorrelation_time == -np.inf:
             #self.determine_correction_slices(T)
             self.simulate_infinite_decorrelation_time(T)


        
        self.values = self.gaussian_values + self.jump_values</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field"><code class="flex name class">
<span>class <span class="ident">simple_ambit_field</span></span>
<span>(</span><span>x, tau, k_s, k_t, nr_simulations, ambit_function=None, decorrelation_time=-inf, gaussian_part_params=None, jump_part_name=None, jump_part_params=None, batch_size=None, total_nr_samples=None, values=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for the simulation, parameter inference and forecasting of ambit fields of the
form <span><span class="MathJax_Preview">Y_t(x) = L(A+(x,t))</span><script type="math/tex">Y_t(x) = L(A+(x,t))</script></span>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>positive number: spacing between ambit sets on the space axis.</dd>
<dt><strong><code>tau</code></strong></dt>
<dd>positive number: spacing between ambit sets on the time axis.</dd>
<dt><strong><code>k_s</code></strong></dt>
<dd>positive integer: number of ambit sets on the space axix.</dd>
<dt><strong><code>k_t</code></strong></dt>
<dd>positive integer: number of ambit sets on the time axis.</dd>
<dt><strong><code>nr_simulation</code></strong></dt>
<dd>positive integer: number of simulations.</dd>
<dt><strong><code>ambit_function</code></strong></dt>
<dd>a non-negative, continuous, strictly increasing function</dd>
<dt><span><span class="MathJax_Preview">\phi \colon (-\infty,0] \to [0,\infty)</span><script type="math/tex">\phi \colon (-\infty,0] \to [0,\infty)</script></span> with <span><span class="MathJax_Preview">\phi(1) &gt; 0, \phi(t) =0</span><script type="math/tex">\phi(1) > 0, \phi(t) =0</script></span> for <span><span class="MathJax_Preview">t&gt;0</span><script type="math/tex">t>0</script></span>.</dt>
<dt><strong><code>decorrelation_time</code></strong></dt>
<dd><span><span class="MathJax_Preview">-\infty</span><script type="math/tex">-\infty</script></span> if the ambit set A is unbounded and finite, negative otherwise.</dd>
<dt><strong><code>gaussian_part_params</code></strong></dt>
<dd>tuple with the mean and standard deviation of the Gaussian part.
</dd>
<dt><strong><code>jump_part_name</code></strong></dt>
<dd>tuple with the parameters of the jump part distribution check helpers.sampler </dd>
<dt>for the parametrisation.</dt>
<dt><strong><code>jump_part_params</code></strong></dt>
<dd>string: name of the jump part distribution. check helpers.sampler for the parametrisation.</dd>
<dt><strong><code>batch_size</code></strong></dt>
<dd>positive integer: number of points to be used at once in the <code>approximate_slices</code> method,</dd>
<dt>in order to optimise for cache memory.</dt>
<dt><strong><code>total_nr_samples</code></strong></dt>
<dd>positive integer: total number of points to be used in the <code>approximate_slices</code> method.</dd>
<dt><strong><code>values</code></strong></dt>
<dd>a numpy array with shape <span><span class="MathJax_Preview">[\text{nr_simulations},k_s,k_t]</span><script type="math/tex">[\text{nr_simulations},k_s,k_t]</script></span> which is passed by the user or </dd>
</dl>
<p>simulated with the method <code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate">simple_ambit_field.simulate()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class simple_ambit_field:
    def __init__(self, x, tau, k_s, k_t, nr_simulations, ambit_function=None, decorrelation_time=-np.inf,
                 gaussian_part_params=None, jump_part_name=None, jump_part_params=None,
                 batch_size=None, total_nr_samples=None, values=None):
        &#34;&#34;&#34;Container class for the simulation, parameter inference and forecasting of ambit fields of the
        form \(Y_t(x) = L(A+(x,t))\).
        
        Args:
          x: positive number: spacing between ambit sets on the space axis.
          tau: positive number: spacing between ambit sets on the time axis.
          k_s: positive integer: number of ambit sets on the space axix.
          k_t: positive integer: number of ambit sets on the time axis.
          nr_simulation: positive integer: number of simulations.
          ambit_function: a non-negative, continuous, strictly increasing function
          \(\phi \colon (-\infty,0] \\to [0,\infty)\) with \(\phi(1) &gt; 0, \phi(t) =0\) for \(t&gt;0\).
          decorrelation_time: \(-\infty\) if the ambit set A is unbounded and finite, negative otherwise.
          gaussian_part_params: tuple with the mean and standard deviation of the Gaussian part.                                                           
          jump_part_name: tuple with the parameters of the jump part distribution check helpers.sampler 
          for the parametrisation.
          jump_part_params: string: name of the jump part distribution. check helpers.sampler for the parametrisation.
          batch_size: positive integer: number of points to be used at once in the `approximate_slices` method,
          in order to optimise for cache memory.
          total_nr_samples: positive integer: total number of points to be used in the `approximate_slices` method.
          values: a numpy array with shape \([\\text{nr_simulations},k_s,k_t]\) which is passed by the user or 
          simulated with the method `simple_ambit_field.simulate`.
        &#34;&#34;&#34;

        #################################################################################
        check_spatio_temporal_positions(x, tau, k_s, k_t, nr_simulations)
        self.x = x
        self.tau = tau
        self.k_s = k_s
        self.k_t = k_t
        self.nr_simulations = nr_simulations

        ### simulation parameters ###
        self.ambit_function = ambit_function
        self.gaussian_part_params = gaussian_part_params
        self.jump_part_name = jump_part_name
        self.jump_part_params = jump_part_params
        self.decorrelation_time = decorrelation_time
        self.total_nr_samples = total_nr_samples
        self.batch_size = batch_size

        ### dimension of the indicator matrix for each minimal slice 
        ### if decorrelation_time &gt;  -inf, I_t = ceiling(decorrelation_time/tau)
        ### if decorrelation_time =  -inf, I_t = k_t - T/tau,
        ### where T = tau * floor{\phi^{-1}(x)/tau + 1} ###
        self.I_t = None
        self.I_s = None   #I_s = math.ceil(self.ambit_function(0)/self.x)


        ### minimal slices on t &gt; T/tau ###
        self.unique_slices = None
        self.unique_slices_areas = None
        
        ### correction slices given by the intersections of ambit sets \(A_ij\) with \(1 \le i \le k_s, 1 \le j \le k_t\)
        ### with \(t &lt; T/tau\), which we list from left to right in an array
        self.correction_slices_areas = None
        
        ### container for gaussian and jump parts. their sum is the result ###
        self.gaussian_values = None
        self.jump_values = None
        
        ### passed by the user or simulated using the simulate method 
        ### must have shape [nr_simulations,k_s,k_t] ###
        if values == None:
            self.values = None

        else:

            assert isinstance(
                values, np.ndarray), &#39;the values argument is not a numpy array&#39;
            assert values.shape == (
                nr_simulations, k_s, k_t), &#39;please check the shape of the values argument&#39;
            self.values = values

        #########################################################################################
        ### infered simulation parameters: skip this if you are only interested in simulations###
        self.inferred_parameters = None

        # self.inferred_parameters is a list with elements dictionaries of the form
        # {&#39;inferred_ambit_function_name&#39;:   , inferred_ambit_function_params:    ,
        # &#39;inferred_gaussian_params&#39;:        ,&#39;inferred_jump_params&#39;:              }

        # inferred_ambit_function        is &#39;exponential&#39;,&#39;gamma&#39;, &#39;ig&#39; or a lambda function
        # inferred_ambit_function_params is a tuple
        # inferred_gaussian_params       is a tuple containing the mean and scale
        # inferred_jump_params           is a dictionary containing the name of the distribution
        # and its params, such as {&#39;gamma&#39;: (1,1)}
        ##########################################################################################

    def delete_values(self):
        &#34;&#34;&#34;Deletes the `values` attribute&#34;&#34;&#34;
        if self.values != None:
            self.values = None
            print(&#39;self.values has been deleted&#39;)
        #else:
            #print(&#39;no values to delete&#39;)

    def determine_slices_from_points(self, points_x, points_t):
        &#34;&#34;&#34;Helper for the &#39;approximate_slices&#39; method. Given random points with coordinates 
        `points_x` and `points_t` coordinates from the uniform distribution on \([x,x+\phi(0)] \\times [0,\\tau]\)
        which do not belong to \(A_{01}\) or \(A_{10}\), we check in which slice \(S\) of \(\mathcal{S}_{kl}\) each point is.
        we do so by using a 3d array with shape  \([\\text{nr_sampled_points},I_s,I_t]\) where the \(i^{\\text{th}}\) element \([i,:,:]\) is a matrix with \(\\text{kl}^{\\text{th}}\) element
        is a boolean given by \(x_i - x \cdot k &lt; \phi(t_i -t \cdot l) \cdot (T &lt; t_i-t \cdot l &lt;0)\)
        where \((x_i,t_i)\)  are the coordinates of the \(i^{\\text{th}}\) uniform random sample. 
        [check description of the indicator here]
        
        Args:\n 
          points_x: x coordinates of the uniformly sampled points
          points_t: t coordinates of the uniformly sampled points
        
        Returns:
          a dictionary with keys given by tuples which represent the indicator matrices of 
          a minimal slice and values given by the number of points contained in the minimal slice
        &#34;&#34;&#34;

        # coordinates at which the ambit field is simulated
        ambit_t_coords = self.tau * np.arange(1, self.I_t+1)
        ambit_x_coords = self.x * np.arange(1, self.I_s+1)
        
        x_ik = np.subtract.outer(points_x, ambit_x_coords)
        x_ikl = np.repeat(x_ik[:, :, np.newaxis], repeats=self.I_t, axis=2)
        t_il = np.subtract.outer(points_t, ambit_t_coords)
        phi_t_ikl = np.repeat(self.ambit_function(
            t_il)[:, np.newaxis, :], repeats=self.I_s, axis=1)
        range_indicator = x_ik &gt; 0
        range_indicator = np.repeat(
            range_indicator[:, :, np.newaxis], repeats=self.I_t, axis=2)

        indicator = (x_ikl &lt; phi_t_ikl) * range_indicator
        
        #in the unlikely case no minimal slice is identified
        if len(indicator) == 0:
            raise ValueError(&#39;use more samples in each batch&#39;)

        # we enumerate the unique indicator matrices together with the frequency counts
        # we change the shape from [total_nr_samples, I_s, I_t]  to [total_nr_samples, I_s * I_t]
        reshaped_indicator = indicator.reshape(indicator.shape[:-2]+(-1,))
        g = (tuple(i) for i in reshaped_indicator)
        return Counter(chain(g))

    def approximate_slices(self):
        &#34;&#34;&#34;Identifies the minimal slices in \(S_{11}\) together with their areas and assigns these value to attributes
        `unique_slices` and `unique_slices_areas`.&#34;&#34;&#34;
        
        print(&#39;Slice estimation procedure has started&#39;)
        start_time = time.time()

        
        if self.batch_size == None:
            self.batch_size = self.total_nr_samples // 10
        self.total_nr_samples = self.batch_size * (self.total_nr_samples // self.batch_size)

        # rectangle to simulate uniform rvs in space-time is [x, x + ambit_function(0)] x [0,tau]
        low_x, high_x = self.x, self.x + self.ambit_function(0)
        low_t, high_t = max(self.tau + self.decorrelation_time, 0), self.tau
        dict_ = dict()

        #use batches of points to optimise for cache memory and prevent memory overflow 
        for batch in range(self.total_nr_samples // self.batch_size):

            points_x = np.random.uniform(
                low=low_x, high=high_x, size=self.batch_size)
            points_t = np.random.uniform(
                low=low_t, high=high_t, size=self.batch_size)

            # throw away points not contained in A_11 = A + (x,tau):
            # (points_x,points_t) in A_11 if: 0 &lt; points_x - x &lt; phi(points_t - tau)
            # i.e. throw away points contained in ambit sets bottom or left of A_11
            # left of A_11: no such points, since we only simulate points with t coordinate &gt; 0
            # bottom of A_11: must be in A_01; condition: (points_x &lt; phi(points_t - tau)) *  (points_x  &gt; 0)

            indicator_in_A_11 = (
                points_x - self.x &lt; self.ambit_function(points_t - self.tau)) * (points_x - self.x &gt; 0)
            indicator_in_A_01 = (points_x &lt; self.ambit_function(
                points_t - self.tau)) * (points_x &gt; 0)
            indicator_bottom_of_A_11 = indicator_in_A_11 * (~indicator_in_A_01)

            points_x = points_x[indicator_bottom_of_A_11]
            points_t = points_t[indicator_bottom_of_A_11]

            dict_to_add = self.determine_slices_from_points(points_x, points_t)

            for k, v in dict_to_add.items():
                if k in dict_:
                    dict_[k] += v
                else:
                    dict_[k] = v
                    
        # to add more diagnostics
        print(&#39;Slice estimation procedure has finished&#39;)
        end_time = time.time()
        print(end_time - start_time)
        
        percentage_points_kept = 100 * sum(dict_.values()) / self.total_nr_samples
        print(f&#34;{round(percentage_points_kept,2)}% of points are used in the slice estimation&#34;)

        nr_unique_indicators = len(dict_.keys())
        self.unique_slices = np.array(list(dict_.keys())).reshape(
            nr_unique_indicators, self.I_s, self.I_t)
        
        self.unique_slices_areas = np.array(list(dict_.values())) * (high_x-low_x) * \
            (high_t - low_t) / self.total_nr_samples
            
            
    def determine_correction_slices(self,T):
        &#34;&#34;&#34;Method to be used in the infinite decorrelation time to determine the areas of the
        intersection of the ambit sets at time coordinates \(\\tau,\ldots, k_t \\tau\) with 
        the region of the plane given by \(t &lt; T\). The result is stored in the attribute
        `correction_slices_areas`.
        &#34;&#34;&#34;
        
        self.correction_slices_areas = [quad(self.ambit_function, a = T - (i+1) * self.tau, b= T - i * self.tau , limit=500)[0]  
                                        for i in range(1,self.k_t)] + [quad(self.ambit_function,a= -np.inf,b=T - self.k_t,limit=500)[0]]
 
        
    @njit
    def simulate_finite_decorrelation_time(self):
        &#34;&#34;&#34;implementation of algorithm  [nr to be added] in [paper link]&#34;&#34;&#34;
        Y_gaussian = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,self.k_t + 2 * self.I_t-2))
        Y_jump     = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,self.k_t + 2 * self.I_t-2))
        for k in range(self.k_s + self.I_s -1):
            for l in range(self.k_t + self.I_t - 1):
                
                gaussian_to_add = np.zeros((self.k_s,self.k_t))
                jump_to_add     = np.zeros((self.k_s,self.k_t))
                
                #simulate S.
                for slice_S,area_S in zip(self.unique_slices,self.unique_slices_areas):
                    tiled_area_S = np.tile(area_S,(self.nr_simulations,1))
                    
                    gaussian_sample_slice = gaussian_part_sampler(self.gaussian_part_params,tiled_area_S)
                    jump_sample_slice     = jump_part_sampler(self.jump_part_params,tiled_area_S,self.jump_part_name)
                    
                    gaussian_to_add += slice_S * gaussian_sample_slice[:,:,np.newaxis]
                    jump_to_add     += slice_S * jump_sample_slice[:,:,np.newaxis]
                    
                Y_gaussian[:,k:k+self.I_s,l:l+self.I_t] +=  gaussian_to_add
                Y_jump[:,k:k+self.I_s,l:l+self.I_t]     +=  jump_to_add
 
        self.gaussian_values =  Y_gaussian[:,self.I_s-1:self.I_s+self.k_s-1,self.I_t-1:self.I_t+self.k_t-1]
        self.jump_values     =  Y_jump[:,self.I_s-1:self.I_s+self.k_s-1,self.I_t-1:self.I_t+self.k_t-1]

    @njit
    def simulate_infinite_decorrelation_time(self,T):
        &#34;&#34;&#34;implementation of algorithm  [nr to be added] in [paper link]&#34;&#34;&#34;

        assert T/self.tau == int(T/self.tau)
        T_tau = -int(T/self.tau)
        
        Y_gaussian = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,2 * self.k_t + 2 * T_tau -1))
        Y_jump     = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,2 * self.k_t + 2 * T_tau -1))
        
        #add correction slices
        self.determine_correction_slices(T)
        correction_slices_matrix   = np.tile(self.correction_slices_areas,(self.nr_simulations,self.k_s,1))
        gaussian_correction_slices = gaussian_part_sampler(self.gaussian_part_params,correction_slices_matrix)
        jump_correction_slices     = jump_part_sampler(self.jump_part_params,correction_slices_matrix,self.jump_part_name)
        
        #gaussian_correction_slices = np.fliplr(np.cumsum(np.fliplr(gaussian_correction_slices),axis=1))
        #jump_correction_slices     = np.fliplr(np.cumsum(np.fliplr(jump_correction_slices),axis=1))
        gaussian_correction_slices = (np.cumsum(gaussian_correction_slices[:,:,::-1],axis=2))[:,:,::-1]
        jump_correction_slices     = (np.cumsum(jump_correction_slices[:,:,::-1],axis=2))[:,:,::-1]

        
        Y_gaussian[:,self.I_s-1:self.I_s - 1+ self.k_s, T_tau:T_tau + self.k_t] +=  gaussian_correction_slices  
        Y_jump[:,self.I_s-1:self.I_s - 1+ self.k_s, T_tau:T_tau + self.k_t]     +=  jump_correction_slices  

        #implementation of algorithm [] from []
        for k in range(self.k_s + self.I_s -1):
            for l in range(self.k_t +  T_tau):

                gaussian_to_add = np.zeros((self.nr_simulations,self.I_s,self.I_t))
                jump_to_add     = np.zeros((self.nr_simulations,self.I_s,self.I_t))
                
                for slice_S,area_S in zip(self.unique_slices,self.unique_slices_areas):
                    tiled_area_S = np.tile(area_S,(self.nr_simulations,1))
                    #simulate S
                    
                    gaussian_sample_slice = gaussian_part_sampler(self.gaussian_part_params,tiled_area_S)
                    jump_sample_slice     = jump_part_sampler(self.jump_part_params,tiled_area_S,self.jump_part_name)
                    
                    gaussian_to_add = slice_S * gaussian_sample_slice[:,:,np.newaxis] 
                    jump_to_add     = slice_S * jump_sample_slice[:,:,np.newaxis] 
                    
                Y_gaussian[:,k:k+self.I_s,l:l+self.I_t] +=  gaussian_to_add
                Y_jump[:,k:k+self.I_s,l:l+self.I_t]     +=  jump_to_add
                    
                    
        self.gaussian_values = Y_gaussian[:,self.I_s-1:self.I_s - 1+ self.k_s,T_tau+1: T_tau+self.k_t+1]
        self.jump_values     = Y_jump[:,self.I_s-1:self.I_s-1+self.k_s,T_tau+1:T_tau+1+self.k_t]
                
    def simulate(self):
        &#34;&#34;&#34;Simulate the ambit field at time coordinates \(\\tau,\ldots,k_t\\tau\) and space
        coordinates \(x,\ldots,k_s x\). The marginal law of this stationary
        process is given by the independent sum of the Gaussian and jump parts. See [] for an example
        and `helpers.sampler&#39; for the parametrisations used. The simulated values are stored in the
        attribute `values`.&#34;&#34;&#34;

        # checks
        self.delete_values()
        check_trawl_function(self.ambit_function)
        check_gaussian_params(self.gaussian_part_params)
        check_jump_part_and_params(self.jump_part_name,self.jump_part_params)



        #set I_s
        self.I_s = math.ceil(self.ambit_function(0)/self.x)
        # set I_t
        if self.decorrelation_time &gt; -np.inf:    
            
            # decorrelation_time checks
            assert self.decorrelation_time &lt; 0, &#39;please check the value of the decorrelation_time&#39;
            assert self.ambit_function(self.decorrelation_time) == 0,\
                            &#39;ambit_function(decorrelation_time) should be 0&#39;
            self.I_t = math.ceil(-self.decorrelation_time/self.tau)
            
            

        elif self.decorrelation_time == -np.inf:
            
            T_tilde = fsolve(lambda t: self.ambit_function(t)-self.x,x0=-1)[0]
            T = self.tau * math.floor(1 + T_tilde/self.tau)
            assert (T/self.tau).is_integer()
            
            self.I_t = int(-T / self.tau) + self.k_t
            
        self.approximate_slices()
        
        if  self.decorrelation_time &gt; -np.inf:           
            self.simulate_finite_decorrelation_time()
            
        elif self.decorrelation_time == -np.inf:
             #self.determine_correction_slices(T)
             self.simulate_infinite_decorrelation_time(T)


        
        self.values = self.gaussian_values + self.jump_values</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.approximate_slices"><code class="name flex">
<span>def <span class="ident">approximate_slices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Identifies the minimal slices in <span><span class="MathJax_Preview">S_{11}</span><script type="math/tex">S_{11}</script></span> together with their areas and assigns these value to attributes
<code>unique_slices</code> and <code>unique_slices_areas</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def approximate_slices(self):
    &#34;&#34;&#34;Identifies the minimal slices in \(S_{11}\) together with their areas and assigns these value to attributes
    `unique_slices` and `unique_slices_areas`.&#34;&#34;&#34;
    
    print(&#39;Slice estimation procedure has started&#39;)
    start_time = time.time()

    
    if self.batch_size == None:
        self.batch_size = self.total_nr_samples // 10
    self.total_nr_samples = self.batch_size * (self.total_nr_samples // self.batch_size)

    # rectangle to simulate uniform rvs in space-time is [x, x + ambit_function(0)] x [0,tau]
    low_x, high_x = self.x, self.x + self.ambit_function(0)
    low_t, high_t = max(self.tau + self.decorrelation_time, 0), self.tau
    dict_ = dict()

    #use batches of points to optimise for cache memory and prevent memory overflow 
    for batch in range(self.total_nr_samples // self.batch_size):

        points_x = np.random.uniform(
            low=low_x, high=high_x, size=self.batch_size)
        points_t = np.random.uniform(
            low=low_t, high=high_t, size=self.batch_size)

        # throw away points not contained in A_11 = A + (x,tau):
        # (points_x,points_t) in A_11 if: 0 &lt; points_x - x &lt; phi(points_t - tau)
        # i.e. throw away points contained in ambit sets bottom or left of A_11
        # left of A_11: no such points, since we only simulate points with t coordinate &gt; 0
        # bottom of A_11: must be in A_01; condition: (points_x &lt; phi(points_t - tau)) *  (points_x  &gt; 0)

        indicator_in_A_11 = (
            points_x - self.x &lt; self.ambit_function(points_t - self.tau)) * (points_x - self.x &gt; 0)
        indicator_in_A_01 = (points_x &lt; self.ambit_function(
            points_t - self.tau)) * (points_x &gt; 0)
        indicator_bottom_of_A_11 = indicator_in_A_11 * (~indicator_in_A_01)

        points_x = points_x[indicator_bottom_of_A_11]
        points_t = points_t[indicator_bottom_of_A_11]

        dict_to_add = self.determine_slices_from_points(points_x, points_t)

        for k, v in dict_to_add.items():
            if k in dict_:
                dict_[k] += v
            else:
                dict_[k] = v
                
    # to add more diagnostics
    print(&#39;Slice estimation procedure has finished&#39;)
    end_time = time.time()
    print(end_time - start_time)
    
    percentage_points_kept = 100 * sum(dict_.values()) / self.total_nr_samples
    print(f&#34;{round(percentage_points_kept,2)}% of points are used in the slice estimation&#34;)

    nr_unique_indicators = len(dict_.keys())
    self.unique_slices = np.array(list(dict_.keys())).reshape(
        nr_unique_indicators, self.I_s, self.I_t)
    
    self.unique_slices_areas = np.array(list(dict_.values())) * (high_x-low_x) * \
        (high_t - low_t) / self.total_nr_samples</code></pre>
</details>
</dd>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.delete_values"><code class="name flex">
<span>def <span class="ident">delete_values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the <code>values</code> attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_values(self):
    &#34;&#34;&#34;Deletes the `values` attribute&#34;&#34;&#34;
    if self.values != None:
        self.values = None
        print(&#39;self.values has been deleted&#39;)</code></pre>
</details>
</dd>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.determine_correction_slices"><code class="name flex">
<span>def <span class="ident">determine_correction_slices</span></span>(<span>self, T)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to be used in the infinite decorrelation time to determine the areas of the
intersection of the ambit sets at time coordinates <span><span class="MathJax_Preview">\tau,\ldots, k_t \tau</span><script type="math/tex">\tau,\ldots, k_t \tau</script></span> with
the region of the plane given by <span><span class="MathJax_Preview">t &lt; T</span><script type="math/tex">t < T</script></span>. The result is stored in the attribute
<code>correction_slices_areas</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_correction_slices(self,T):
    &#34;&#34;&#34;Method to be used in the infinite decorrelation time to determine the areas of the
    intersection of the ambit sets at time coordinates \(\\tau,\ldots, k_t \\tau\) with 
    the region of the plane given by \(t &lt; T\). The result is stored in the attribute
    `correction_slices_areas`.
    &#34;&#34;&#34;
    
    self.correction_slices_areas = [quad(self.ambit_function, a = T - (i+1) * self.tau, b= T - i * self.tau , limit=500)[0]  
                                    for i in range(1,self.k_t)] + [quad(self.ambit_function,a= -np.inf,b=T - self.k_t,limit=500)[0]]</code></pre>
</details>
</dd>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.determine_slices_from_points"><code class="name flex">
<span>def <span class="ident">determine_slices_from_points</span></span>(<span>self, points_x, points_t)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper for the 'approximate_slices' method. Given random points with coordinates
<code>points_x</code> and <code>points_t</code> coordinates from the uniform distribution on <span><span class="MathJax_Preview">[x,x+\phi(0)] \times [0,\tau]</span><script type="math/tex">[x,x+\phi(0)] \times [0,\tau]</script></span>
which do not belong to <span><span class="MathJax_Preview">A_{01}</span><script type="math/tex">A_{01}</script></span> or <span><span class="MathJax_Preview">A_{10}</span><script type="math/tex">A_{10}</script></span>, we check in which slice <span><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span> of <span><span class="MathJax_Preview">\mathcal{S}_{kl}</span><script type="math/tex">\mathcal{S}_{kl}</script></span> each point is.
we do so by using a 3d array with shape
<span><span class="MathJax_Preview">[\text{nr_sampled_points},I_s,I_t]</span><script type="math/tex">[\text{nr_sampled_points},I_s,I_t]</script></span> where the <span><span class="MathJax_Preview">i^{\text{th}}</span><script type="math/tex">i^{\text{th}}</script></span> element <span><span class="MathJax_Preview">[i,:,:]</span><script type="math/tex">[i,:,:]</script></span> is a matrix with <span><span class="MathJax_Preview">\text{kl}^{\text{th}}</span><script type="math/tex">\text{kl}^{\text{th}}</script></span> element
is a boolean given by <span><span class="MathJax_Preview">x_i - x \cdot k &lt; \phi(t_i -t \cdot l) \cdot (T &lt; t_i-t \cdot l &lt;0)</span><script type="math/tex">x_i - x \cdot k < \phi(t_i -t \cdot l) \cdot (T < t_i-t \cdot l <0)</script></span>
where <span><span class="MathJax_Preview">(x_i,t_i)</span><script type="math/tex">(x_i,t_i)</script></span>
are the coordinates of the <span><span class="MathJax_Preview">i^{\text{th}}</span><script type="math/tex">i^{\text{th}}</script></span> uniform random sample.
[check description of the indicator here]</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>points_x</code></strong></dt>
<dd>x coordinates of the uniformly sampled points</dd>
<dt><strong><code>points_t</code></strong></dt>
<dd>t coordinates of the uniformly sampled points</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a dictionary with keys given by tuples which represent the indicator matrices of
a minimal slice and values given by the number of points contained in the minimal slice</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_slices_from_points(self, points_x, points_t):
    &#34;&#34;&#34;Helper for the &#39;approximate_slices&#39; method. Given random points with coordinates 
    `points_x` and `points_t` coordinates from the uniform distribution on \([x,x+\phi(0)] \\times [0,\\tau]\)
    which do not belong to \(A_{01}\) or \(A_{10}\), we check in which slice \(S\) of \(\mathcal{S}_{kl}\) each point is.
    we do so by using a 3d array with shape  \([\\text{nr_sampled_points},I_s,I_t]\) where the \(i^{\\text{th}}\) element \([i,:,:]\) is a matrix with \(\\text{kl}^{\\text{th}}\) element
    is a boolean given by \(x_i - x \cdot k &lt; \phi(t_i -t \cdot l) \cdot (T &lt; t_i-t \cdot l &lt;0)\)
    where \((x_i,t_i)\)  are the coordinates of the \(i^{\\text{th}}\) uniform random sample. 
    [check description of the indicator here]
    
    Args:\n 
      points_x: x coordinates of the uniformly sampled points
      points_t: t coordinates of the uniformly sampled points
    
    Returns:
      a dictionary with keys given by tuples which represent the indicator matrices of 
      a minimal slice and values given by the number of points contained in the minimal slice
    &#34;&#34;&#34;

    # coordinates at which the ambit field is simulated
    ambit_t_coords = self.tau * np.arange(1, self.I_t+1)
    ambit_x_coords = self.x * np.arange(1, self.I_s+1)
    
    x_ik = np.subtract.outer(points_x, ambit_x_coords)
    x_ikl = np.repeat(x_ik[:, :, np.newaxis], repeats=self.I_t, axis=2)
    t_il = np.subtract.outer(points_t, ambit_t_coords)
    phi_t_ikl = np.repeat(self.ambit_function(
        t_il)[:, np.newaxis, :], repeats=self.I_s, axis=1)
    range_indicator = x_ik &gt; 0
    range_indicator = np.repeat(
        range_indicator[:, :, np.newaxis], repeats=self.I_t, axis=2)

    indicator = (x_ikl &lt; phi_t_ikl) * range_indicator
    
    #in the unlikely case no minimal slice is identified
    if len(indicator) == 0:
        raise ValueError(&#39;use more samples in each batch&#39;)

    # we enumerate the unique indicator matrices together with the frequency counts
    # we change the shape from [total_nr_samples, I_s, I_t]  to [total_nr_samples, I_s * I_t]
    reshaped_indicator = indicator.reshape(indicator.shape[:-2]+(-1,))
    g = (tuple(i) for i in reshaped_indicator)
    return Counter(chain(g))</code></pre>
</details>
</dd>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Simulate the ambit field at time coordinates <span><span class="MathJax_Preview">\tau,\ldots,k_t\tau</span><script type="math/tex">\tau,\ldots,k_t\tau</script></span> and space
coordinates <span><span class="MathJax_Preview">x,\ldots,k_s x</span><script type="math/tex">x,\ldots,k_s x</script></span>. The marginal law of this stationary
process is given by the independent sum of the Gaussian and jump parts. See [] for an example
and `helpers.sampler' for the parametrisations used. The simulated values are stored in the
attribute <code>values</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self):
    &#34;&#34;&#34;Simulate the ambit field at time coordinates \(\\tau,\ldots,k_t\\tau\) and space
    coordinates \(x,\ldots,k_s x\). The marginal law of this stationary
    process is given by the independent sum of the Gaussian and jump parts. See [] for an example
    and `helpers.sampler&#39; for the parametrisations used. The simulated values are stored in the
    attribute `values`.&#34;&#34;&#34;

    # checks
    self.delete_values()
    check_trawl_function(self.ambit_function)
    check_gaussian_params(self.gaussian_part_params)
    check_jump_part_and_params(self.jump_part_name,self.jump_part_params)



    #set I_s
    self.I_s = math.ceil(self.ambit_function(0)/self.x)
    # set I_t
    if self.decorrelation_time &gt; -np.inf:    
        
        # decorrelation_time checks
        assert self.decorrelation_time &lt; 0, &#39;please check the value of the decorrelation_time&#39;
        assert self.ambit_function(self.decorrelation_time) == 0,\
                        &#39;ambit_function(decorrelation_time) should be 0&#39;
        self.I_t = math.ceil(-self.decorrelation_time/self.tau)
        
        

    elif self.decorrelation_time == -np.inf:
        
        T_tilde = fsolve(lambda t: self.ambit_function(t)-self.x,x0=-1)[0]
        T = self.tau * math.floor(1 + T_tilde/self.tau)
        assert (T/self.tau).is_integer()
        
        self.I_t = int(-T / self.tau) + self.k_t
        
    self.approximate_slices()
    
    if  self.decorrelation_time &gt; -np.inf:           
        self.simulate_finite_decorrelation_time()
        
    elif self.decorrelation_time == -np.inf:
         #self.determine_correction_slices(T)
         self.simulate_infinite_decorrelation_time(T)


    
    self.values = self.gaussian_values + self.jump_values</code></pre>
</details>
</dd>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate_finite_decorrelation_time"><code class="name flex">
<span>def <span class="ident">simulate_finite_decorrelation_time</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>implementation of algorithm
[nr to be added] in [paper link]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def simulate_finite_decorrelation_time(self):
    &#34;&#34;&#34;implementation of algorithm  [nr to be added] in [paper link]&#34;&#34;&#34;
    Y_gaussian = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,self.k_t + 2 * self.I_t-2))
    Y_jump     = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,self.k_t + 2 * self.I_t-2))
    for k in range(self.k_s + self.I_s -1):
        for l in range(self.k_t + self.I_t - 1):
            
            gaussian_to_add = np.zeros((self.k_s,self.k_t))
            jump_to_add     = np.zeros((self.k_s,self.k_t))
            
            #simulate S.
            for slice_S,area_S in zip(self.unique_slices,self.unique_slices_areas):
                tiled_area_S = np.tile(area_S,(self.nr_simulations,1))
                
                gaussian_sample_slice = gaussian_part_sampler(self.gaussian_part_params,tiled_area_S)
                jump_sample_slice     = jump_part_sampler(self.jump_part_params,tiled_area_S,self.jump_part_name)
                
                gaussian_to_add += slice_S * gaussian_sample_slice[:,:,np.newaxis]
                jump_to_add     += slice_S * jump_sample_slice[:,:,np.newaxis]
                
            Y_gaussian[:,k:k+self.I_s,l:l+self.I_t] +=  gaussian_to_add
            Y_jump[:,k:k+self.I_s,l:l+self.I_t]     +=  jump_to_add

    self.gaussian_values =  Y_gaussian[:,self.I_s-1:self.I_s+self.k_s-1,self.I_t-1:self.I_t+self.k_t-1]
    self.jump_values     =  Y_jump[:,self.I_s-1:self.I_s+self.k_s-1,self.I_t-1:self.I_t+self.k_t-1]</code></pre>
</details>
</dd>
<dt id="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate_infinite_decorrelation_time"><code class="name flex">
<span>def <span class="ident">simulate_infinite_decorrelation_time</span></span>(<span>self, T)</span>
</code></dt>
<dd>
<div class="desc"><p>implementation of algorithm
[nr to be added] in [paper link]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit
def simulate_infinite_decorrelation_time(self,T):
    &#34;&#34;&#34;implementation of algorithm  [nr to be added] in [paper link]&#34;&#34;&#34;

    assert T/self.tau == int(T/self.tau)
    T_tau = -int(T/self.tau)
    
    Y_gaussian = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,2 * self.k_t + 2 * T_tau -1))
    Y_jump     = np.zeros((self.nr_simulations,self.k_s + 2 *self.I_s -2,2 * self.k_t + 2 * T_tau -1))
    
    #add correction slices
    self.determine_correction_slices(T)
    correction_slices_matrix   = np.tile(self.correction_slices_areas,(self.nr_simulations,self.k_s,1))
    gaussian_correction_slices = gaussian_part_sampler(self.gaussian_part_params,correction_slices_matrix)
    jump_correction_slices     = jump_part_sampler(self.jump_part_params,correction_slices_matrix,self.jump_part_name)
    
    #gaussian_correction_slices = np.fliplr(np.cumsum(np.fliplr(gaussian_correction_slices),axis=1))
    #jump_correction_slices     = np.fliplr(np.cumsum(np.fliplr(jump_correction_slices),axis=1))
    gaussian_correction_slices = (np.cumsum(gaussian_correction_slices[:,:,::-1],axis=2))[:,:,::-1]
    jump_correction_slices     = (np.cumsum(jump_correction_slices[:,:,::-1],axis=2))[:,:,::-1]

    
    Y_gaussian[:,self.I_s-1:self.I_s - 1+ self.k_s, T_tau:T_tau + self.k_t] +=  gaussian_correction_slices  
    Y_jump[:,self.I_s-1:self.I_s - 1+ self.k_s, T_tau:T_tau + self.k_t]     +=  jump_correction_slices  

    #implementation of algorithm [] from []
    for k in range(self.k_s + self.I_s -1):
        for l in range(self.k_t +  T_tau):

            gaussian_to_add = np.zeros((self.nr_simulations,self.I_s,self.I_t))
            jump_to_add     = np.zeros((self.nr_simulations,self.I_s,self.I_t))
            
            for slice_S,area_S in zip(self.unique_slices,self.unique_slices_areas):
                tiled_area_S = np.tile(area_S,(self.nr_simulations,1))
                #simulate S
                
                gaussian_sample_slice = gaussian_part_sampler(self.gaussian_part_params,tiled_area_S)
                jump_sample_slice     = jump_part_sampler(self.jump_part_params,tiled_area_S,self.jump_part_name)
                
                gaussian_to_add = slice_S * gaussian_sample_slice[:,:,np.newaxis] 
                jump_to_add     = slice_S * jump_sample_slice[:,:,np.newaxis] 
                
            Y_gaussian[:,k:k+self.I_s,l:l+self.I_t] +=  gaussian_to_add
            Y_jump[:,k:k+self.I_s,l:l+self.I_t]     +=  jump_to_add
                
                
    self.gaussian_values = Y_gaussian[:,self.I_s-1:self.I_s - 1+ self.k_s,T_tau+1: T_tau+self.k_t+1]
    self.jump_values     = Y_jump[:,self.I_s-1:self.I_s-1+self.k_s,T_tau+1:T_tau+1+self.k_t]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ambit_stochastics" href="index.html">ambit_stochastics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field">simple_ambit_field</a></code></h4>
<ul class="">
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.approximate_slices" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.approximate_slices">approximate_slices</a></code></li>
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.delete_values" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.delete_values">delete_values</a></code></li>
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.determine_correction_slices" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.determine_correction_slices">determine_correction_slices</a></code></li>
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.determine_slices_from_points" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.determine_slices_from_points">determine_slices_from_points</a></code></li>
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate">simulate</a></code></li>
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate_finite_decorrelation_time" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate_finite_decorrelation_time">simulate_finite_decorrelation_time</a></code></li>
<li><code><a title="ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate_infinite_decorrelation_time" href="#ambit_stochastics.simple_ambit_field.simple_ambit_field.simulate_infinite_decorrelation_time">simulate_infinite_decorrelation_time</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>